#include "L138_LCDK_aic3106_init.h"
#include "evmomapl138_gpio.h"
#include <stdint.h>
#include <math.h>
#include "L138_LCDK_switch_led.h"
#include "hamming_constants.h"
#include <ti/dsplib/dsplib.h>
#include "nnet.h"


double mfcc_proc[13]; //should be our MFCCs
extern double* mfcc;

//preprocessing
double x1_step1_xoffset[13] = {28.28398,-11.65919,0.5675173,-16.9357,
		-13.34606,-7.606739,-8.34811,-6.825197,-5.954667,-6.722548,-4.678594,-5.638944,-3.289066};
double x1_step1_gain[13] = {0.0560836139383484,0.0794685145745256,0.0536538360251369,
		0.0740072208845417,0.103484718540969,0.13057390626726,0.157182695096929,0.229841308367051,
		0.208959908325109,0.213654030882408,0.200555056173466,0.192997603066269,0.258062684716431};
double x1_step1_ymin = -1;

// Layer 1
double b1 [5]= {-1.183557045541087982,0.17953213459713049382,-1.5949224450307473155,0.47786377390309275892,1.4347091079340064113};
double IW1_1[5][13] = {
	    {0.493186679150389,-0.655023636738734,-1.58907105056058,-0.671175463450202,0.0557351140914809,0.457942645443162,-0.0424229198962122,-0.962848094046683,-0.169703906450517,-1.29326436058782,-0.521079675176976,-1.55697983740444,-0.730267939035300},
	    {-0.936306385291874,-0.297178853963483,0.551078995536751,0.158208225773722,-0.855623475725215,-0.896487502694733,-0.0521537150262756,-0.399577789784232,0.452584226008117,-0.196987879222797,-0.672565363857875,-0.422111658487805,-0.553046982956028},
	    {0.352349550223308,-0.0564608034098724,-0.306029966178879,-1.93405068594884,-0.310140879715684,1.27978327305918,0.533558916522493,-0.662619121161324,-0.532926135231454,0.280843665538178,1.01713709746084,-0.611574308795433,-0.635007660009604},
	    {0.820908366495405,0.469873933264459,0.0173689197038923,-1.53840951955917,1.60325648121016,0.744554625156800,0.578757279699235,0.192353076617686,-0.128304001584955,0.916773102908278,0.821942939894642,0.903338402441147,0.306642805653851},
	    {0.958285977750901,-0.536439597270897,-0.823053064833404,-0.612079358218852,0.631443156484539,0.839862935332723,0.0990768604376076,0.536003218375735,-0.954245021347596,-0.0693466205825344,0.215932527924803,-1.13593332234848,-0.110475525161731}
	};

// Layer 2
double b2 [4] = {0.21109771974399341166,-0.64250347668790497302,-0.31419527186766910143,-0.33508556053272248176};
double LW2_1[4][5] ={
	    {1.81848399609883,-1.37750151787381,6.01215813549043,1.87848779475035,2.00097370100905},
	    {3.41608995155076,0.580075976737844,-1.50132319910719,-3.37084210206348,2.12475375824946},
	    {-2.50579980592036,0.429463408695987,-1.62343213705078,-3.22481529292064,-5.26236985978323},
	    {-3.59996454870284,-1.36294069100192,-2.10754233263611,3.94850352088950,0.798643041253323},
	};

double hidden[NUM_NEURONS]; //stores the output of the hidden layers

double output_temp[NUM_OUTPUTS];//same as o[k] in the slides
double output[NUM_OUTPUTS];

double sigmoid(double x)
{
    return(2.0/(1+exp(-2*x)) - 1);
}

double softmax(uint8_t x){
    //where x is the index into the output_temp array
    double sum;
    sum = 0;
    uint8_t i;
    for(i = 0; i < NUM_OUTPUTS; i++)
    {
        sum += exp(output_temp[i]);
    }
    return( (exp(output_temp[x])/sum) );
}

void nNet()
{

    //preprocessing steps
    uint8_t i;
    for(i = 0; i < 13; i++)
    {
        mfcc_proc[i] = mfcc[i] - x1_step1_xoffset[i];
        mfcc_proc[i] = mfcc_proc[i] * x1_step1_gain[i];
        mfcc_proc[i] = mfcc_proc[i] + x1_step1_ymin;
    }

    uint8_t x; //where x is the xth hidden layer neuron

    for(x = 0; x < NUM_NEURONS; x++)
    {
        double temp;
        temp = 0;
        uint8_t k; //where k is the kth input neuron
        for(k = 0; k < NUM_INPUTS; k++){
            temp += IW1_1[x][k] * mfcc_proc[k];
        }
        hidden[x] = sigmoid(temp + b1[x]);
    }

    for(x = 0; x < NUM_OUTPUTS; x++)
    {
        double temp;
        uint8_t k;//where k is the kth hidden neuron
        for(k = 0; k < NUM_NEURONS; k++)
        {
            temp += LW2_1[x][k] * hidden[k];
        }
        output_temp[x] = temp + b2[x];
    }

    for(x = 0; x < NUM_OUTPUTS; x++)
    {
        output[x] = softmax(x);
    }
}
