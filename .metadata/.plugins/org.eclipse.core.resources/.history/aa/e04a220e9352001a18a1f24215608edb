#include "L138_LCDK_aic3106_init.h"
#include "evmomapl138_gpio.h"
#include <stdint.h>
#include <math.h>
#include "L138_LCDK_switch_led.h"
#include "hamming_constants.h"
#include <ti/dsplib/dsplib.h>
#include "nnet.h"
#define N 1024

//#ifndef TRAINING
//#define TRAINING 1
//#endif

#define FILTER_BANK_SIZE 26
#define NUM_MFCCs 13

uint8_t mfcc_done;

#define NUM_PHIS (FILTER_BANK_SIZE + 2)

int16_t data[N];

#pragma DATA_ALIGN(ham_data,8);
float ham_data[2 * N]; //input to FFT
float fft_mag[N];

int32_t counter;

int32_t led_counter;
#define ign_samples 1024

int bool;
int rec_finished;
int ham_finished;

#pragma DATA_ALIGN(y_sp,8);
float   y_sp [2*N]; //output from FFT
#pragma DATA_ALIGN(w_sp,8);
float   w_sp [2*N]; //FFT twiddles

#define PI 3.14159265358979323

float y_real_sp [N];
float y_imag_sp [N];

float fft_resolution = 0;

float psd[N];

float pos_slopes[FILTER_BANK_SIZE] = {0.012314,0.011345,0.010451,0.0096281,
		0.0088699,0.0081714,0.0075279,0.0069351,0.006389,0.0058859,
		0.0054224,0.0049954,0.004602,0.0042396,0.0039057,0.0035981,
		0.0033148,0.0030538,0.0028133,0.0025917,0.0023876,0.0021996,
		0.0020264,0.0018668,0.0017198,0.0015844};

float neg_slopes[FILTER_BANK_SIZE] = {-0.011345,-0.010451,-0.0096281,-0.0088699,
		-0.0081714,-0.0075279,-0.0069351,-0.006389,-0.0058859,-0.0054224,
		-0.0049954,-0.004602,-0.0042396,-0.0039057,-0.0035981,-0.0033148,
		-0.0030538,-0.0028133,-0.0025917,-0.0023876,-0.0021996,-0.0020264,
		-0.0018668,-0.0017198,-0.0015844,-0.0014596};

float phis[NUM_PHIS] = {250,331.21,419.35,515.04,618.9,731.64,854.02,986.86,1131,
		1287.6,1457.5,1641.9,1842.1,2059.4,2295.2,2551.3,2829.2,3130.9,3458.3,3813.8,
		4199.6,4618.5,5073.1,5566.6,6102.3,6683.7,7314.9,8000};

float y_filters [FILTER_BANK_SIZE]; //filter bank output
float x_filters [FILTER_BANK_SIZE]; //log (y_filters)

float mfcc [NUM_MFCCs];

uint8_t hold;

separateRealImg () {
    int i, j;

    for (i = 0, j = 0; j < N; i+=2, j++) {
        y_real_sp[j] = y_sp[i];
        y_imag_sp[j] = y_sp[i + 1];
    }
}

unsigned char brev[64] = {
    0x0, 0x20, 0x10, 0x30, 0x8, 0x28, 0x18, 0x38,
    0x4, 0x24, 0x14, 0x34, 0xc, 0x2c, 0x1c, 0x3c,
    0x2, 0x22, 0x12, 0x32, 0xa, 0x2a, 0x1a, 0x3a,
    0x6, 0x26, 0x16, 0x36, 0xe, 0x2e, 0x1e, 0x3e,
    0x1, 0x21, 0x11, 0x31, 0x9, 0x29, 0x19, 0x39,
    0x5, 0x25, 0x15, 0x35, 0xd, 0x2d, 0x1d, 0x3d,
    0x3, 0x23, 0x13, 0x33, 0xb, 0x2b, 0x1b, 0x3b,
    0x7, 0x27, 0x17, 0x37, 0xf, 0x2f, 0x1f, 0x3f
};

// Function for generating sequence of twiddle factors
void gen_twiddle_fft_sp (float *w, int n)
{
    int i, j, k;
    double x_t, y_t, theta1, theta2, theta3;

    for (j = 1, k = 0; j <= n >> 2; j = j << 2)
    {
        for (i = 0; i < n >> 2; i += j)
        {
            theta1 = 2 * PI * i / n;
            x_t = cos (theta1);
            y_t = sin (theta1);
            w[k] = (float) x_t;
            w[k + 1] = (float) y_t;

            theta2 = 4 * PI * i / n;
            x_t = cos (theta2);
            y_t = sin (theta2);
            w[k + 2] = (float) x_t;
            w[k + 3] = (float) y_t;

            theta3 = 6 * PI * i / n;
            x_t = cos (theta3);
            y_t = sin (theta3);
            w[k + 4] = (float) x_t;
            w[k + 5] = (float) y_t;
            k += 6;
        }
    }
}

interrupt void interrupt4(void) // interrupt service routine
{
	int16_t left_sample = input_right_sample();

	if (hold == 0)
	{
		if (led_counter < 16000)
		{
			LCDK_LED_on(4);
			led_counter++;
			rec_finished = 0;
		}
		else
		{

			if(counter<ign_samples)
			{
				rec_finished = 0;
				counter++;

			}

			else if(counter-ign_samples < N)
			{
				data[counter-ign_samples] = left_sample;

				if(counter-ign_samples == N - 1)
				{
					rec_finished = 1;
					LCDK_LED_off(4);
				}
				else
				{
					rec_finished = 0;
				}
				counter++;
			}


		}
	}
	else
	{
		rec_finished = 0;
	}

	output_right_sample(0);


}


void multiply_hamming()
{
	//multiply with the hamming window

	uint16_t a = 0;

	for(; a < N; a++)
	{
		ham_data[2*a] = (float)data[a] * (float)hamming_cos_lookup[a]; // real part
		ham_data[2*a + 1] = 0;                                     // imaginary part
	}
}

void compute_fft()
{
	DSPF_sp_fftSPxSP(N,ham_data,w_sp,y_sp,brev,4,0,N);

	uint16_t i;
	i = 0;
	for(;i < N; i++){
		psd[i] = y_sp[2*i] * y_sp[2*i] + y_sp[2*i+1] * y_sp[2*i+1]; //psd = fft output magnitude squared
		fft_mag[i] = sqrt(y_sp[2*i] * y_sp[2*i] + y_sp[2*i+1] * y_sp[2*i+1]); //psd
	}
}

void multiply_filter_banks()
{
	uint16_t i;
	for (i = 0; i < FILTER_BANK_SIZE; i++)
	{
		//for each filter

		//find start index of psd for current filter (ceil(filter start phi / FFT resolution))

		float filter_start_phi = phis[i];

		uint16_t psd_start_index = (uint16_t)(ceil(filter_start_phi/fft_resolution));

		//find last index of psd on positive slope of current filter (floor(filter peak phi / FFT resolution))

		float filter_peak_phi = phis[i+1];

		uint16_t psd_last_pos_index = (uint16_t)(filter_peak_phi/fft_resolution);

		//find end index of psd for current filter (floor(filter end phi / FFT resolution))

		float filter_end_phi = phis[i+2];
		uint16_t psd_end_index = (uint16_t)(filter_end_phi/fft_resolution);

		//multiply and accumulate with linear interpolation

		//positive slope
		uint16_t j;
		float accumulator = 0;
		for (j=psd_start_index; j < psd_last_pos_index; j++)
		{
			float cur_freq = fft_resolution * j;
			accumulator += psd[j] * (pos_slopes[i] * (cur_freq - filter_start_phi));
		}
		//negative slope

		for (j = psd_last_pos_index + 1; j < psd_end_index; j++)
		{
			float cur_freq = fft_resolution * j;
			accumulator += psd[j] * (neg_slopes[i] * (cur_freq - filter_peak_phi) + 1);
		}

		//store sum

		y_filters[i] = accumulator;

		// store log of sum

		x_filters[i] = (float)(log((double)accumulator));
	}
}

void calculate_mfccs()
{
	//sigma 1..26 X_m cos((m - 0.5) * k*pi/26);

	uint8_t m = 0;

	float accumulator = 0;

	uint8_t k = 0;

	for (k = 1; k <= 13; k++)
	{
		for (m = 1; m <= 26; m++)
		{
			accumulator += (float)(x_filters[m - 1] * cos((double)(((double)m - 1/2.0) * (k * PI)/(26.0))));
		}

		mfcc[k-1] = accumulator;
		accumulator = 0;
	}

}

//void nNet();

double mfcc_proc[13]; //should be our MFCCs


double x1_step1_xoffset[13] = {28.28398,-11.65919,0.5675173,-16.9357,
		-13.34606,-7.606739,-8.34811,-6.825197,-5.954667,-6.722548,-4.678594,-5.638944,-3.289066};
double x1_step1_gain[13] = {0.0560836139383484,0.0794685145745256,0.0536538360251369,
		0.0740072208845417,0.103484718540969,0.13057390626726,0.157182695096929,0.229841308367051,
		0.208959908325109,0.213654030882408,0.200555056173466,0.192997603066269,0.258062684716431};
double x1_step1_ymin = -1;

// Layer 1
double b1 [5]= {-1.183557045541087982,0.17953213459713049382,-1.5949224450307473155,0.47786377390309275892,1.4347091079340064113};
double IW1_1[5][13] = {
	    {0.493186679150389,-0.655023636738734,-1.58907105056058,-0.671175463450202,0.0557351140914809,0.457942645443162,-0.0424229198962122,-0.962848094046683,-0.169703906450517,-1.29326436058782,-0.521079675176976,-1.55697983740444,-0.730267939035300},
	    {-0.936306385291874,-0.297178853963483,0.551078995536751,0.158208225773722,-0.855623475725215,-0.896487502694733,-0.0521537150262756,-0.399577789784232,0.452584226008117,-0.196987879222797,-0.672565363857875,-0.422111658487805,-0.553046982956028},
	    {0.352349550223308,-0.0564608034098724,-0.306029966178879,-1.93405068594884,-0.310140879715684,1.27978327305918,0.533558916522493,-0.662619121161324,-0.532926135231454,0.280843665538178,1.01713709746084,-0.611574308795433,-0.635007660009604},
	    {0.820908366495405,0.469873933264459,0.0173689197038923,-1.53840951955917,1.60325648121016,0.744554625156800,0.578757279699235,0.192353076617686,-0.128304001584955,0.916773102908278,0.821942939894642,0.903338402441147,0.306642805653851},
	    {0.958285977750901,-0.536439597270897,-0.823053064833404,-0.612079358218852,0.631443156484539,0.839862935332723,0.0990768604376076,0.536003218375735,-0.954245021347596,-0.0693466205825344,0.215932527924803,-1.13593332234848,-0.110475525161731}
	};

// Layer 2
double b2 [4] = {0.21109771974399341166,-0.64250347668790497302,-0.31419527186766910143,-0.33508556053272248176};
double LW2_1 = {1.8184839960988261609,-1.3775015178738068133,6.0121581354904334304,1.8784877947503511031,2.000973701009050032,3.4160899515507585633,0.58007597673784372372,-1.5013231991071882554,-3.3708421020634786736,2.1247537582494633313,-2.5057998059203643315,0.42946340869598725876,-1.6234321370507838189,-3.2248152929206406192,-5.2623698597832309076,-3.5999645487028373303,-1.3629406910019188359,-2.1075423326361106824,3.9485035208895000736,0.79864304125332319373};

double hidden[NUM_NEURONS]; //stores the output of the hidden layers

double output_temp[NUM_OUTPUTS];//same as o[k] in the slides
double output[NUM_OUTPUTS];

double sigmoid(double x)
{
    return(2.0/(1+exp(-2*x)) - 1);
}

double softmax(uint8_t x){
    //where x is the index into the output_temp array
    double sum;
    sum = 0;
    uint8_t i;
    for(i = 0; i < NUM_OUTPUTS; i++)
    {
        sum += exp(output_temp[i]);
    }
    return( (exp(output_temp[x])/sum) );
}

void nNet()
{

    //preprocessing steps
    uint8_t i;
    for(i = 0; i < 13; i++)
    {
        mfcc_proc[i] = mfcc[i] - x1_step1_xoffset[i];
        mfcc_proc[i] = mfcc_proc[i] * x1_step1_gain[i];
        mfcc_proc[i] = mfcc_proc[i] + x1_step1_ymin;
    }

    uint8_t x; //where x is the xth hidden layer neuron

    for(x = 0; x < NUM_NEURONS; x++)
    {
        double temp;
        temp = 0;
        uint8_t k; //where k is the kth input neuron
        for(k = 0; k < NUM_INPUTS; k++){
            temp += IW1_1[x][k] * mfcc_proc[k];
        }
        hidden[x] = sigmoid(temp + b1[x]);
    }

    for(x = 0; x < NUM_OUTPUTS; x++)
    {
        double temp;
        uint8_t k;//where k is the kth hidden neuron
        for(k = 0; k < NUM_NEURONS; k++)
        {
            temp += LW2_1[x][k] * hidden[k];
        }
        output_temp[x] = temp + b2[x];
    }

    for(x = 0; x < NUM_OUTPUTS; x++)
    {
        output[x] = softmax(x);
    }
}

int main(void)
{
	counter = 0;
	bool = 1;
	led_counter = 0;
	rec_finished = 0;

	mfcc_done = 0;

	fft_resolution = (16000)/N;

	uint16_t p = 0;

	for (p = 0 ; p < 2*N; p++)
	{
		ham_data[p] = 0.0;
	}

	LCDK_LED_init();
	gen_twiddle_fft_sp(w_sp,N);
	L138_initialise_intr(FS_16000_HZ,ADC_GAIN_0DB,DAC_ATTEN_0DB,LCDK_MIC_INPUT);

	while(1)
	{
		//user should press, then unpress record button on GUI composer to begin recording

		if(bool == 1)
		{
			counter = 0;	 // reset counter to allow data overwrite
			led_counter = 0; // reset led counter to being 1 second countdown
			hold = 1;        // enter into hold state (waiting for button unpress)
			mfcc_done = 0;   // after collecting data, we want to clear old mfcc
		}
		else
		{
			hold = 0;		 // on button unpress, begin recording data
		}

		if(rec_finished == 1 && mfcc_done == 0)
		{
			//multiply with the hamming window
			multiply_hamming();

			//compute the FFT

			compute_fft();

			//multiply by filter banks

			multiply_filter_banks();

			//calculate cepstrum coefficients

			calculate_mfccs();

#ifndef TRAINING
			nNet();
#endif //TRAINING

			mfcc_done = 1; //only want the computation to occur once

		}
	}

}
